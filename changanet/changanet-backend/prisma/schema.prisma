/**
 * @archivo prisma/schema.prisma - Esquema de base de datos de Changánet
 * @descripción Define estructura relacional completa de la plataforma (REQ-01 a REQ-45)
 * @sprint Sprint 1 – Autenticación y Perfiles
 * @tarjeta Tarjeta 1: [Backend] Implementar API de Registro y Login
 * @impacto Económico: Base de datos robusta para transacciones seguras y escalables
 */

generator client {
  provider = "prisma-client-js"
}

generator erd {
  provider = "prisma-erd-generator"
  output = "../docs/database-diagram.png"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

enum EstadoServicio {
  PENDIENTE
  AGENDADO
  COMPLETADO
  CANCELADO
}

enum EstadoCotizacion {
  PENDIENTE
  ACEPTADO
  RECHAZADO
}

// MODELO: usuarios
// FUNCIÓN: Almacena todos los usuarios del sistema (clientes y profesionales).
// RELACIÓN PRD: REQ-01 (Registro), REQ-02 (Login), REQ-03 (Verificación de email).
// TARJETA BACKEND: Tarjeta 1: [Backend] Implementar API de Registro y Login.
// SPRINT: Sprint 1 (Primera Entrega) - "Implementación del producto de software".
model usuarios {
  id                    String    @id @default(uuid())
  email                 String    @unique
  hash_contrasena       String?
  nombre                String
  telefono              String?
  rol                   String    @default("cliente")
  esta_verificado       Boolean   @default(false)
  bloqueado             Boolean   @default(false) // RB-05: Usuarios bloqueados no pueden acceder
  token_verificacion    String?   @unique
  token_expiracion      DateTime?
  creado_en             DateTime  @default(now())
  actualizado_en        DateTime?
  google_id             String?   @unique
  url_foto_perfil       String?
  fcm_token             String?   // Token para notificaciones push FCM
  sms_enabled           Boolean   @default(false) // Permite envío de notificaciones SMS

  perfil_profesional perfiles_profesionales?
  servicios_como_cliente servicios[] @relation("ServicioCliente")
  servicios_como_profesional servicios[] @relation("ServicioProfesional")
  resenas_escritas resenas[]
  mensajes_enviados mensajes[] @relation("MensajeRemitente")
  mensajes_recibidos mensajes[] @relation("MensajeDestinatario")
  disponibilidad disponibilidad[]
  notificaciones notificaciones[]
  cotizaciones_como_cliente cotizaciones[] @relation("CotizacionCliente")
  cotizaciones_como_profesional cotizaciones[] @relation("CotizacionProfesional")
  verification_request verification_requests?
  pagos_como_cliente pagos[] @relation("PagoCliente")
  pagos_como_profesional pagos[] @relation("PagoProfesional")

  // Relaciones para servicios recurrentes
  servicios_recurrrentes_cliente servicios_recurrrentes[] @relation("ServicioRecurrenteCliente")
  servicios_recurrrentes_profesional servicios_recurrrentes[] @relation("ServicioRecurrenteProfesional")

  // Relaciones para favoritos
  favoritos_como_cliente favoritos[] @relation("FavoritoCliente")
  favoritos_como_profesional favoritos[] @relation("FavoritoProfesional")

  // Relaciones para logros y gamificación
  logros_obtenidos logros_usuario[]

  @@index([rol])
  @@index([esta_verificado])
  @@index([telefono])
  @@index([sms_enabled])
}

// MODELO: perfiles_profesionales
// FUNCIÓN: Almacena la información específica de los profesionales.
// RELACIÓN PRD: REQ-06 (Foto), REQ-07 (Especialidad), REQ-08 (Experiencia), REQ-09 (Zona), REQ-10 (Tarifas).
// TARJETA BACKEND: Tarjeta 2: [Backend] Implementar API para Gestión de Perfiles Profesionales.
// SPRINT: Sprint 1 (Primera Entrega) - "Implementación del producto de software".
model perfiles_profesionales {
  usuario_id       String   @id @default(uuid()) // PK y FK que enlaza con usuarios.id
  usuario          usuarios @relation(fields: [usuario_id], references: [id])

  especialidad     String
  anos_experiencia Int?
  zona_cobertura   String
  latitud          Float?   // Coordenadas GPS para cálculo de distancia real
  longitud         Float?   // Coordenadas GPS para cálculo de distancia real
  tarifa_hora      Float
  descripcion      String?
  url_foto_perfil  String?
  calificacion_promedio Float?
  estado_verificacion String @default("pendiente")
  verificado_en    DateTime?
  url_documento_verificacion String?

  @@index([especialidad])
  @@index([zona_cobertura])
  @@index([calificacion_promedio])
  @@index([latitud, longitud])
  @@index([especialidad, zona_cobertura, calificacion_promedio])
}

// MODELO: servicios
// FUNCIÓN: Representa un servicio contratado, conectando a un cliente con un profesional.
// RELACIÓN PRD: REQ-29 (Agendamiento), RB-02 (Solo reseñas si el servicio está completado).
// TARJETA BACKEND: Tarjeta 6: [Backend] Implementar API de Gestión de Disponibilidad (parte de agendamiento).
// SPRINT: Sprint 2 (Segunda Entrega) - "Consolidar y mejorar el producto".
model servicios {
  id             String   @id @default(uuid())
  cliente_id     String
  cliente        usuarios @relation("ServicioCliente", fields: [cliente_id], references: [id])
  profesional_id String
  profesional    usuarios @relation("ServicioProfesional", fields: [profesional_id], references: [id])
  descripcion    String
  estado         EstadoServicio @default(PENDIENTE)
  fecha_agendada DateTime?
  creado_en      DateTime @default(now())
  completado_en  DateTime?
  resena         resenas?
  pago           pagos?

  // Relación con servicios recurrentes
  servicio_recurrente_id String?
  servicio_recurrente servicios_recurrrentes? @relation(fields: [servicio_recurrente_id], references: [id])

  @@index([cliente_id])
  @@index([profesional_id])
  @@index([estado])
  @@index([creado_en])
  @@index([cliente_id, estado])
  @@index([profesional_id, estado])
  @@index([estado, creado_en])
  @@index([fecha_agendada])
  @@index([cliente_id, fecha_agendada])
  @@index([profesional_id, fecha_agendada])
}

model resenas {
  id            String   @id @default(uuid())
  servicio_id   String   @unique
  servicio      servicios @relation(fields: [servicio_id], references: [id])
  cliente_id    String
  cliente       usuarios @relation(fields: [cliente_id], references: [id])
  calificacion  Int
  comentario    String?
  url_foto      String?
  creado_en     DateTime @default(now())

  @@index([servicio_id])
}

// MODELO: mensajes
// FUNCIÓN: Almacena el historial de comunicación entre usuarios (el chat).
// RELACIÓN PRD: REQ-16 (Chat interno), REQ-17 (Mensajes de texto), REQ-18 (Imágenes), REQ-20 (Historial).
// TARJETA BACKEND: Tarjeta 4: [Backend] Implementar API de Chat en Tiempo Real.
// SPRINT: Sprint 1 (Primera Entrega) - "Implementación del producto de software".
model mensajes {
  id             String   @id @default(uuid()) // Identificador único del mensaje
  remitente_id   String   // FK que enlaza con el usuario remitente
  remitente      usuarios @relation("MensajeRemitente", fields: [remitente_id], references: [id])
  destinatario_id String  // FK que enlaza con el usuario destinatario
  destinatario   usuarios @relation("MensajeDestinatario", fields: [destinatario_id], references: [id])
  contenido      String
  url_imagen     String?
  esta_leido     Boolean  @default(false)
  creado_en      DateTime @default(now())

  @@index([remitente_id, creado_en])
  @@index([destinatario_id, creado_en])
  @@index([remitente_id, destinatario_id, creado_en])
  @@index([creado_en])
}

// MODELO: disponibilidad
// FUNCIÓN: Gestiona los horarios en los que un profesional está disponible para trabajar.
// RELACIÓN PRD: REQ-26 (Calendario), REQ-27 (Horarios), REQ-28 (Visibilidad).
// TARJETA BACKEND: Tarjeta 6: [Backend] Implementar API de Gestión de Disponibilidad.
// SPRINT: Sprint 2 (Segunda Entrega) - "Consolidar y mejorar el producto".
model disponibilidad {
  id            String   @id @default(uuid()) // Identificador único del bloque de disponibilidad
  profesional_id String  // FK que enlaza con el profesional
  profesional   usuarios @relation(fields: [profesional_id], references: [id])
  fecha         DateTime // REQ-27: Fecha del bloque de disponibilidad
  hora_inicio   DateTime // REQ-27: Hora de inicio del bloque
  hora_fin      DateTime // REQ-27: Hora de fin del bloque
  esta_disponible Boolean @default(true)
}

// MODELO: notificaciones
// FUNCIÓN: Almacena las alertas automáticas que recibe el usuario.
// RELACIÓN PRD: REQ-19 (Notificaciones automáticas).
// TARJETA BACKEND: Tarjeta 4: [Backend] Implementar API de Chat en Tiempo Real (parte de notificaciones).
// SPRINT: Sprint 1 (Primera Entrega) - "Implementación del producto de software".
model notificaciones {
  id         String   @id @default(uuid()) // Identificador único de la notificación
  usuario_id String   // FK que enlaza con el usuario receptor
  usuario    usuarios @relation(fields: [usuario_id], references: [id])
  tipo       String
  mensaje    String   // Contenido de la notificación
  esta_leido Boolean  @default(false)
  creado_en  DateTime @default(now()) // Fecha de creación de la notificación
}
model cotizaciones {
  id             String   @id @default(uuid())
  cliente_id     String
  cliente        usuarios @relation("CotizacionCliente", fields: [cliente_id], references: [id])
  profesional_id String
  profesional    usuarios @relation("CotizacionProfesional", fields: [profesional_id], references: [id])
  descripcion    String
  zona_cobertura String?
  estado         EstadoCotizacion @default(PENDIENTE)
  precio         Float?
  comentario     String?
  creado_en      DateTime @default(now())
  aceptado_en    DateTime?
  rechazado_en   DateTime?

  @@index([cliente_id, estado])
  @@index([profesional_id, estado])
  @@index([estado, creado_en])
}

// MODELO: verification_requests
// FUNCIÓN: Gestiona solicitudes de verificación de identidad para profesionales.
// RELACIÓN PRD: REQ-36 (Subir documento), REQ-37 (Insignia verificado), REQ-40 (Aprobación admin).
// TARJETA BACKEND: Tarjeta 8: [Backend] Implementar Sistema de Verificación de Identidad.
// SPRINT: Sprint 3 (Tercera Entrega) - "Verificación y confianza".
model verification_requests {
  id            String   @id @default(uuid())
  usuario_id    String   @unique // Un usuario solo puede tener una solicitud activa
  usuario       usuarios @relation(fields: [usuario_id], references: [id])
  documento_url String   // URL del documento subido (Cloudinary/Firebase)
  estado        String   @default("pendiente") // "pendiente", "aprobado", "rechazado"
  comentario_admin String? // Comentario del administrador al aprobar/rechazar
  creado_en     DateTime @default(now())
  revisado_en   DateTime?
  revisado_por  String?  // ID del administrador que revisó
}

// MODELO: pagos
// FUNCIÓN: Registra todas las transacciones de pago para trazabilidad y generación de comprobantes
// RELACIÓN PRD: REQ-41 (Integración pasarelas), REQ-42 (Custodia), REQ-44 (Retiro), REQ-45 (Comprobantes)
// TARJETA BACKEND: Tarjeta 7: [Backend] Implementar Sistema de Pagos y Comisiones
// SPRINT: Sprint 3 – Servicios y Transacciones
model pagos {
  id                String   @id @default(uuid())
  servicio_id       String   @unique
  servicio          servicios @relation(fields: [servicio_id], references: [id])
  cliente_id        String
  cliente           usuarios @relation("PagoCliente", fields: [cliente_id], references: [id])
  profesional_id    String
  profesional       usuarios @relation("PagoProfesional", fields: [profesional_id], references: [id])
  monto_total       Float
  comision_plataforma Float
  monto_profesional Float
  mercado_pago_id   String?  @unique // ID del pago en Mercado Pago
  estado            String   @default("pendiente") // "pendiente", "aprobado", "liberado", "reembolsado"
  metodo_pago       String?  // "tarjeta", "transferencia", etc.
  fecha_pago        DateTime?
  fecha_liberacion  DateTime?
  url_comprobante   String?  // URL del comprobante generado
  creado_en         DateTime @default(now())

  @@index([cliente_id])
  @@index([profesional_id])
  @@index([estado])
  @@index([mercado_pago_id])
}

// MODELO: servicios_recurrrentes
// FUNCIÓN: Gestiona servicios programados de forma recurrente (semanal, mensual, etc.)
// RELACIÓN PRD: Optimización - Programación automática de servicios recurrentes
// SPRINT: Optimización - Servicios recurrentes
// IMPACTO: Mejora retención de clientes y ingresos estables para profesionales
model servicios_recurrrentes {
  id             String   @id @default(uuid())
  cliente_id     String
  cliente        usuarios @relation("ServicioRecurrenteCliente", fields: [cliente_id], references: [id])
  profesional_id String
  profesional    usuarios @relation("ServicioRecurrenteProfesional", fields: [profesional_id], references: [id])

  descripcion    String
  frecuencia     String   // "semanal", "quincenal", "mensual", "bimestral", "trimestral"
  dia_semana     Int?     // 0-6 (domingo a sábado) para frecuencia semanal
  dia_mes       Int?     // 1-31 para frecuencia mensual
  hora_inicio   String   // HH:MM format
  duracion_horas Float    // duración estimada en horas

  tarifa_base   Float    // tarifa por servicio individual
  descuento_recurrencia Float @default(0) // descuento porcentual por ser recurrente

  fecha_inicio  DateTime
  fecha_fin     DateTime? // opcional, si es indefinido
  activo        Boolean  @default(true)

  creado_en     DateTime @default(now())
  actualizado_en DateTime?

  // Servicios individuales generados automáticamente
  servicios_generados servicios[]

  @@index([cliente_id])
  @@index([profesional_id])
  @@index([activo])
  @@index([fecha_inicio])
  @@index([frecuencia])
}

// Note: Enums converted to String types for SQLite compatibility
// Valid values:
// - rol: "cliente", "profesional", "admin"
// - estado_verificacion: "pendiente", "verificado", "rechazado"
// - estado (servicios): "pendiente", "agendado", "completado", "pagado", "cancelado"
// - tipo (notificaciones): "nuevo_mensaje", "nueva_cotizacion", "servicio_agendado", "resena_recibida", "pago_liberado", "fondos_liberados"
// - estado (cotizaciones): "pendiente", "aceptado", "rechazado"
// - frecuencia (servicios_recurrrentes): "semanal", "quincenal", "mensual", "bimestral", "trimestral"
// - estado (pagos): "pendiente", "aprobado", "liberado", "reembolsado"

// MODELO: favoritos
// FUNCIÓN: Permite a los clientes marcar profesionales como favoritos para acceso rápido
// RELACIÓN PRD: Mejora UX para clientes recurrentes
// SPRINT: Mejoras de UX
model favoritos {
  id             String   @id @default(uuid())
  cliente_id     String
  cliente        usuarios @relation("FavoritoCliente", fields: [cliente_id], references: [id])
  profesional_id String
  profesional    usuarios @relation("FavoritoProfesional", fields: [profesional_id], references: [id])
  creado_en      DateTime @default(now())

  @@unique([cliente_id, profesional_id]) // Un cliente solo puede tener un favorito por profesional
  @@index([cliente_id])
  @@index([profesional_id])
}

// MODELO: logros
// FUNCIÓN: Sistema de medallas y logros para gamificación (REQ-38)
// RELACIÓN PRD: REQ-38 (Medallas por logros)
// SPRINT: Gamificación
model logros {
  id          String   @id @default(uuid())
  nombre      String   // Nombre del logro (ej: "Primer Servicio", "Cliente Recurrente")
  descripcion String   // Descripción del logro
  icono       String   // Emoji o URL del icono
  categoria   String   // "servicios", "resenas", "verificacion", "experiencia"
  criterio    String   // Condición para obtener el logro (ej: "servicios_completados >= 1")
  puntos      Int      @default(0) // Puntos que otorga el logro
  activo      Boolean  @default(true)
  creado_en   DateTime @default(now())

  // Relación con logros obtenidos por usuarios
  logros_usuario logros_usuario[]

  @@index([categoria])
  @@index([activo])
}

// MODELO: logros_usuario
// FUNCIÓN: Registra qué logros ha obtenido cada usuario
// RELACIÓN PRD: REQ-38 (Sistema de medallas)
model logros_usuario {
  id         String   @id @default(uuid())
  usuario_id String
  usuario    usuarios @relation(fields: [usuario_id], references: [id])
  logro_id   String
  logro      logros   @relation(fields: [logro_id], references: [id])
  obtenido_en DateTime @default(now())

  @@unique([usuario_id, logro_id]) // Un usuario solo puede obtener un logro una vez
  @@index([usuario_id])
  @@index([logro_id])
}